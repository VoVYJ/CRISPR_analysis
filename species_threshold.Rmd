# Function

```{r}
readMAF <- function(maf_file) {
  lines <- readLines(maf_file)
  
  score <- label <- mult <- NA
  maf_df <- data.frame()
  i <- 1
  
  while (i <= length(lines)) {
    line <- trimws(lines[i])
    
    if (startsWith(line, "a")) {
      # 提取 a 行信息
      fields <- strsplit(line, "\\s+")[[1]]
      for (field in fields[-1]) {
        kv <- strsplit(field, "=")[[1]]
        if (length(kv) == 2) {
          if (kv[1] == "score") score <- as.numeric(kv[2])
          if (kv[1] == "label") label <- kv[2]
          if (kv[1] == "mult")  mult  <- as.integer(kv[2])
        }
      }
    }
    
    if (startsWith(line, "s") && i + 1 <= length(lines)) {
      fields <- strsplit(line, "\\s+")[[1]]
     
      new_row <- data.frame(
        score    = score,
        label    = label,
        mult     = mult,
        src      = fields[2],
        start    = as.integer(fields[3]),
        size     = as.integer(fields[4]),
        strand   = fields[5],
        srcSize  = as.integer(fields[6]),
        seq      = fields[7],
        stringsAsFactors = FALSE
      )
      
      maf_df <- rbind(maf_df, new_row)
      i <- i + 1  # 跳过 s 行和 seq 行
    } else {
      i <- i + 1  # 普通行，继续
    }
  }
  
  return(maf_df)
}



```

# read data
```{r}
Es_genus_maf = readMAF("/Users/wangyujia/Lab Doc/HGT quantification/species_threshold/Escherichia_sp_WGA.maf")

library(stringr)
genome2species = unique(str_split_fixed(Es_genus_maf$src, "\\.", 2)[, 1])
genome2species = data.frame(genome = genome2species,species = c("Escherichia coli_E","Escherichia fergusonii","Escherichia albertii","Escherichia marmotae","Escherichia sp002965065","Escherichia coli","Escherichia sp004211955","Escherichia sp005843885","Escherichia whittamii","Escherichia ruysiae","Escherichia coli_F"))

Es_genus_maf$srcGenome = str_split_fixed(Es_genus_maf$src, "\\.", 2)[, 1]
Es_genus_maf$species = match(Es_genus_maf$srcGenome,genome2species$genome)
Es_genus_maf$species = genome2species$species[Es_genus_maf$species]

Es_genus_maf$length = ifelse(Es_genus_maf$score != 0,Es_genus_maf$score, Es_genus_maf$size)
Es_genus_maf = Es_genus_maf[Es_genus_maf$length <= 30000 & Es_genus_maf$length >= 1000,]
```

# calculate function

```{r}
colnames(Es_genus_maf)

compare_seq_by_window <- function(seq1, seq2, window_size = 100) {
  chars1 <- unlist(strsplit(seq1, ""))
  chars2 <- unlist(strsplit(seq2, ""))
  
  # 去除双方都是 "-" 的位置
  keep_idx <- which(!(chars1 == "-" & chars2 == "-"))
  clean1 <- chars1[keep_idx]
  clean2 <- chars2[keep_idx]
  
  len <- length(clean1)
  num_windows <- ceiling(len / window_size)
  mismatch_per_window <- integer(num_windows)
  
  for (i in seq_len(num_windows)) {
    start <- (i - 1) * window_size + 1
    end <- min(i * window_size, len)
    mismatch_per_window[i] <- sum(clean1[start:end] != clean2[start:end])
  }
  
  return(list(
    num_windows = num_windows,
    mismatches = mismatch_per_window
  ))
}

## test

temp =compare_seq_by_window(Es_genus_maf$seq[1],Es_genus_maf$seq[2])
```

# calculation

```{r}
#library(dplyr)

# 假设 maf_df 已经读入，包含 species、label、seq 等列
species_list <- unique(Es_genus_maf$species)
pair_list <- combn(species_list, 2, simplify = FALSE)

remove(results_all)

for (pair in pair_list) {
  sp1 <- pair[1]
  sp2 <- pair[2]
  
  df1 <- Es_genus_maf[Es_genus_maf$species == sp1,]
  df2 <- Es_genus_maf[Es_genus_maf$species == sp2,]
  
  all_labels <- union(df1$label, df2$label)
  
  num_windows = 0
  mismatches = 0
  for (label in all_labels) {
    row1 <- df1[df1$label == label,]
    row2 <- df2[df2$label == label,]
    
    if (nrow(row1) > 0 && nrow(row2) > 0) {
      res <- compare_seq_by_window(row1$seq[1], row2$seq[1], window_size = 100)
      num_windows = num_windows + res$num_windows
      if(!is.na(sum(res$mismatches)))  mismatches = mismatches + sum(res$mismatches)
      # pair_results[[label]] <- data.frame(
      #   label = label,
      #   type = "shared",
      #   num_windows = res$num_windows,
      #   mismatches = paste(res$mismatches, collapse = ","),
      #   species1 = sp1,
      #   species2 = sp2
      # )
    } else {
      seq_only <- if (nrow(row1) > 0) row1$seq[1] else row2$seq[1]
      owner <- if (nrow(row1) > 0) sp1 else sp2
      seq_clean <- gsub("-", "", seq_only)
      len <- nchar(seq_clean)
      #num_windows = num_windows + ceiling(len / 100)
      mismatches = mismatches + (len/100)
      # pair_results[[label]] <- data.frame(
      #   label = label,
      #   type = "unique",
      #   species = owner,
      #   sequence_length = len,
      #   num_windows = num_windows,
      #   species1 = sp1,
      #   species2 = sp2
      # )
    }
  }
  temp_dataframe <- data.frame(
    mismatchs = mismatches,
    num_windows = num_windows,
    species1 = sp1,
    species2 = sp2
  )
  if(!exists("results_all")) {
    results_all = temp_dataframe
  } else  results_all = rbind(results_all, temp_dataframe)
}

results_all$percentage  = results_all$mismatchs/(100*results_all$num_windows)
 
```
## tree
```{r}
library(ape)
# 假设 results_all 有三列：species1, species2, percentage
# 创建物种列表
species <- unique(c(results_all$species1, results_all$species2))

# 初始化一个距离矩阵
dist_mat <- matrix(0, nrow = length(species), ncol = length(species))
rownames(dist_mat) <- colnames(dist_mat) <- species

# 填入距离值（percentage）
for (i in 1:nrow(results_all)) {
  s1 <- results_all$species1[i]
  s2 <- results_all$species2[i]
  dist <- results_all$percentage[i]
  
  dist_mat[s1, s2] <- dist
  dist_mat[s2, s1] <- dist  # 保证对称
}


# 转换为 dist 对象
dist_obj <- as.dist(dist_mat)

# 构建树（使用邻接法/Neighbor-Joining 或 UPGMA）
tree <- nj(dist_obj)  # 或者 upgma(dist_obj) if needed


# 基本绘图
plot(tree, cex = 0.8)

# 或者使用 ggtree 更好看的版本
library(ggtree)
ggtree(tree) +  
  geom_tiplab(size = 3) +
  theme_tree2() +  # 显示横坐标轴
  xlab("Genetic distance")+
  xlim(0,0.3)
ggsave("./Figure/speciation_tree.pdf",width = 5,height = 4)
```


# speciation visualization
## sympatric
```{r}
file_list = list.files("./speciation/sympatric/")
remove(all_data)
  for (file in  file_list) {
    temp_dist = readRDS(paste0("./speciation/sympatric/",file))
    
    temp_pop_size = unlist(strsplit(file,split = "_"))[4]
    temp_rep = substr(unlist(strsplit(file,split = "_"))[7],1,1)
    temp_category = unlist(strsplit(file,split = "_"))[3]
    
    temp_dist$generation = as.integer(temp_dist$generation)
    temp_dist$pop_size = rep(temp_pop_size,nrow(temp_dist))
    temp_dist$rep = rep(temp_rep,nrow(temp_dist))
    temp_dist$model = rep(temp_category,nrow(temp_dist))
    
    
    if(exists("all_data")) {
      all_data = rbind(all_data, temp_dist)
    }
    else all_data = temp_dist
    
    print(file)
  }

all_hist_data_mean = aggregate(all_data$count*all_data$mids,by = list(all_data$generation,all_data$rep,all_data$pop_size,all_data$model),function(x) sum(x)/500000)
    colnames(all_hist_data_mean) = c("generation","rep","pop_size","model","mean")
    
    all_hist_data_sd = aggregate(all_hist_data_mean$mean,by = list(all_hist_data_mean$generation,all_hist_data_mean$pop_size,all_hist_data_mean$model),sd)
    
    all_hist_data = aggregate(all_hist_data_mean$mean,by = list(all_hist_data_mean$generation,all_hist_data_mean$pop_size,all_hist_data_mean$model),mean)
    all_hist_data =cbind(all_hist_data,all_hist_data_sd$x)
    colnames(all_hist_data) = c("generation","pop_size","model","mean","sd")
```

## allopatric
```{r}
With_ANG_distance = read.csv("./speciation/With_ANG_genome_distance.csv",col.names = c("Group","Rep1","Rep2","Generation","Distance"))
Without_ANG_distance = read.csv("./speciation/Without_ANG_genome_distance.csv",col.names = c("Group","Rep1","Rep2","Generation","Distance"))


sum_distance = rbind(With_ANG_distance,Without_ANG_distance[-121,])
sum_distance$Distance = as.numeric(sum_distance$Distance)
sum_distance$Generation = as.numeric(sum_distance$Generation)
library(ggplot2)

ggplot() +
  # allopatric
  geom_point(data = sum_distance, aes(x = Generation, y = Distance, color = Group),size = 3) +
  geom_line(data = sum_distance,aes(x = Generation, y = Distance, color = Group), linewidth = 1) +
  # sympatric
  geom_point(data = all_hist_data, aes(x = generation, y = mean,color = model),size = 3) +
  geom_line(data = all_hist_data,aes(x = generation, y = mean,color = model), linewidth = 1) +
  labs(x = "Generation", y = "Distance") +
  theme_minimal() +
  theme(
    text = element_text(size = 14),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 11)
  )

```

## full matrix
### Without_ANG
```{r}
# 参数设置
generations <- as.integer(seq(200000, 1000000, by = 200000))

# 遍历每个代数
for (gen in generations) {
  # 构造文件路径
  file_path <- paste0(
    "./speciation/Without_ANG_full_matrix/Without_ANG_dist_mat_gen_",
    gen,
    "rep1_vs_rep2.csv"
  )

  # 读取数据
  mat <- as.matrix(read.csv(file_path, row.names = 1))
  
  # 转换为距离矩阵
  dist_mat <- as.dist(mat)

  mds_result <- cmdscale(dist_mat, k = 2)  # k=2 表示降为二维

  mds_df <- data.frame(
    Dim1 = mds_result[, 1],
    Dim2 = mds_result[, 2],
    Group = rep(c("Pop1", "Pop2"), each = 1000)
  )

  # 绘图
  ggplot(mds_df, aes(x = Dim1, y = Dim2, color = Group)) +
    geom_point(size = 0.5,alpha = 0.7) +
    labs(x = "Dim1", y = "Dim2") +
    scale_color_manual(values = c("orange","purple"))+
    theme_minimal(base_size = 18)+
    xlim(-1.05e-3,1.05e-3)+
    ylim(-1.4e-3,1.4e-3)

  ggsave(paste("./Figure/Without_ANG_PCA_at_Generation_", gen,".jpg"),width = 7,height = 5)
}

```


### With_ANG
```{r}
# 参数设置
generations <- as.integer(seq(200000, 1000000, by = 200000))

# 遍历每个代数
for (gen in generations) {
  # 构造文件路径
  file_path <- paste0(
    "./speciation/With_ANG_full_matrix/With_ANG_dist_mat_gen_",
    gen,
    "rep1_vs_rep2.csv"
  )

  # 读取数据
  mat <- as.matrix(read.csv(file_path, row.names = 1))
  
  # 转换为距离矩阵
  dist_mat <- as.dist(mat)

  mds_result <- cmdscale(dist_mat, k = 2)  # k=2 表示降为二维

  mds_df <- data.frame(
    Dim1 = mds_result[, 1],
    Dim2 = mds_result[, 2],
    Group = rep(c("Pop1", "Pop2"), each = 1000)
  )
  
  # 绘图
  ggplot(mds_df, aes(x = Dim1, y = Dim2, color = Group)) +
    geom_point(size=0.5,alpha = 0.7) +
    labs( x = "Dim1", y = "Dim2") +
    scale_color_manual(values = c("orange","purple"))+
    theme_minimal(base_size = 18)+
    xlim(-1.05e-3,1.05e-3)+
    ylim(-1.4e-3,1.4e-3)
  ggsave(paste("./Figure/With_ANG_PCA_at_Generation_", gen,".jpg"),width = 7,height = 5)
}
```

## full matrix 3D
```{r}
library(scatterplot3d)
```

### Without_ANG

```{r}
# 参数设置
generations <- as.integer(seq(200000, 1000000, by = 200000))

# 遍历每个代数
for (gen in generations) {
  # 构造文件路径
  file_path <- paste0(
    "./speciation/Without_ANG_full_matrix/Without_ANG_dist_mat_gen_",
    gen,
    "rep1_vs_rep2.csv"
  )

  # 读取数据
  mat <- as.matrix(read.csv(file_path, row.names = 1))
  
  # 转换为距离矩阵
  dist_mat <- as.dist(mat)

  # 三维MDS
  mds_3d <- cmdscale(dist_mat, k = 3)
  
  # 分组标记
  group_labels <- rep(c("Group1", "Group2"), each = 1000)
  color_pattern <- ifelse(group_labels == "Group1", "#E3A189", "#9C83CE")
  
  plot_data <- data.frame(
    Dim1 = mds_3d[, 1],
    Dim2 = mds_3d[, 2],
    Dim3 = mds_3d[, 3]
  )
  
  # PDF 输出路径
  pdf(paste("./Figure/Without_ANG_3dMDS_at_Generation_", gen,".pdf"),width = 10,height = 10)
  
  # 三维图绘制
  scatterplot3d(
    plot_data$Dim1, plot_data$Dim2, plot_data$Dim3,
    pch = 16,
    cex.symbols = 0.8, 
    color = color_pattern,
    xlim = c(-0.0015, 0.0015),   # 固定 x 坐标区间
    ylim = c(-0.0015, 0.0015),   # 固定 y 坐标区间
    zlim = c(-0.0015, 0.0015),   # 固定 z 坐标区间
    xlab = "Coordinate1", ylab = "Coordinate2", zlab = "Coordinate3"
  )

  dev.off()
}

c("#E97B5F", "#8B6FCB", "#65B6A0", "#D5A86E")
c("#E97B5F", "#8B6FCB", "#65B6A0", "#D5A86E", "#4C91D9", "#C06C94")


```
### With_ANG
```{r}
# 参数设置
#generations <- as.integer(seq(200000, 1000000, by = 200000))
generations <- as.integer(c(500000))
# 遍历每个代数
for (gen in generations) {
  # 构造文件路径
  file_path <- paste0(
    "./speciation/With_ANG_full_matrix/With_ANG_dist_mat_gen_",
    gen,
    "rep1_vs_rep2.csv"
  )

  # 读取数据
  mat <- as.matrix(read.csv(file_path, row.names = 1))
  
  # 转换为距离矩阵
  dist_mat <- as.dist(mat)

  # 三维MDS
  mds_3d <- cmdscale(dist_mat, k = 3)
  
  # 分组标记
  group_labels <- rep(c("Group1", "Group2"), each = 1000)
  color_pattern <- ifelse(group_labels == "Group1", "#88B8A6", "#D1B58C")
  
  plot_data <- data.frame(
    Dim1 = mds_3d[, 1],
    Dim2 = mds_3d[, 2],
    Dim3 = mds_3d[, 3]
  )
  
  # PDF 输出路径
  pdf(paste("./Figure/With_ANG_3dMDS_at_Generation_", gen,".pdf"),width = 10,height = 10)
  
  # 三维图绘制
  scatterplot3d(
    plot_data$Dim1, plot_data$Dim2, plot_data$Dim3,
    pch = 16,
    cex.symbols = 0.8, 
    color = color_pattern,
    xlim = c(-0.0015, 0.0015),   # 固定 x 坐标区间
    ylim = c(-0.0015, 0.0015),   # 固定 y 坐标区间
    zlim = c(-0.0015, 0.0015),   # 固定 z 坐标区间
    xlab = "Coordinate1", ylab = "Coordinate2", zlab = "Coordinate3"
  )

  dev.off()
}
```

### With CRISPR
```{r}
# 参数设置
#generations <- as.integer(seq(200000, 1000000, by = 200000))
generations <- as.integer(c(500000))
# 遍历每个代数
for (gen in generations) {
  # 构造文件路径
  file_path <- paste0(
    "./speciation/With_CRISPR_full_matrix/With_CRISPR_dist_mat_gen_",
    gen,
    "rep1_vs_rep2.csv"
  )

  # 读取数据
  mat <- as.matrix(read.csv(file_path, row.names = 1))
  
  # 转换为距离矩阵
  dist_mat <- as.dist(mat)

  # 三维MDS
  mds_3d <- cmdscale(dist_mat, k = 3)
  
  # 分组标记
  group_labels <- rep(c("Group1", "Group2"), each = 1000)
  color_pattern <- ifelse(group_labels == "Group1", "#4C91D9", "#C06C94")
  
  plot_data <- data.frame(
    Dim1 = mds_3d[, 1],
    Dim2 = mds_3d[, 2],
    Dim3 = mds_3d[, 3]
  )
  
  # PDF 输出路径
  pdf(paste("./Figure/With_CRISPR_3dMDS_at_Generation_", gen,".pdf"),width = 10,height = 10)
  
  # 三维图绘制
  scatterplot3d(
    plot_data$Dim1, plot_data$Dim2, plot_data$Dim3,
    pch = 16,
    cex.symbols = 0.8, 
    color = color_pattern,
    xlim = c(-0.0015, 0.0015),   # 固定 x 坐标区间
    ylim = c(-0.0015, 0.0015),   # 固定 y 坐标区间
    zlim = c(-0.0015, 0.0015),   # 固定 z 坐标区间
    xlab = "Coordinate1", ylab = "Coordinate2", zlab = "Coordinate3"
  )

  dev.off()
}

```

# speciation distance distribution
```{r}
sim_models <- c("With_ANG", "Without_ANG", "With_CRISPR")
generations <- as.integer(10^(0:7))

# 初始化空数据框
all_dist_data <- data.frame(model = character(),
                            generation = integer(),
                            distance = double(),
                            stringsAsFactors = FALSE)

for (sim_model in sim_models) {
  for (gen in generations) {
    
    # 构造文件路径
    file_path <- paste0("./speciation/", sim_model, "_full_matrix/",
                        sim_model, "_dist_mat_gen_", gen, "rep1_vs_rep2.csv")
    
    # 读取并处理矩阵
    mat <- as.matrix(read.csv(file_path, row.names = 1))
    allopatric_mat <- mat[1:1000, 1001:2000]
    
    # 提取上三角（不含对角线）值
    upper_tri_vals <- allopatric_mat[upper.tri(allopatric_mat)]
    
    # 构造临时数据框
    temp_df <- data.frame(
      model = rep(sim_model, length(upper_tri_vals)),
      generation = gen,
      distance = upper_tri_vals
    )
    
    # 合并进总数据框
    all_dist_data <- rbind(all_dist_data, temp_df)
  }
}


```

## vis
```{r}

# 确保 generation 为 factor（x 轴排序用）
all_dist_data$generation <- as.factor(as.character(all_dist_data$generation))
all_dist_data$model <- as.factor(all_dist_data$model)

# 计算每组平均值（用于连线）
mean_df <- all_dist_data %>%
  group_by(model, generation) %>%
  summarise(mean_distance = mean(distance), .groups = "drop")

# 画图
ggplot(all_dist_data, aes(x = generation, y = (distance), fill = model)) +
  # violin plot
  #geom_violin(scale = "width", color = "black", alpha = 0.7,adjust = 2) 
  # 连线：用预先计算的平均值数据
  geom_line(data = mean_df,
            aes(x = generation, y = mean_distance, group = model, color = model),
            size = 1.2) +
  
  # 美化主题
  theme_minimal(base_size = 18) +
  labs(
    x = "Generation",
    y = "Distance",
    fill = "Model",
    color = "Model"
  ) +
  
  scale_fill_manual(values = c("With_ANG" = "#E97B5F","Without_ANG" = "#8B6FCB","With_CRISPR" = "#65B6A0")) +
  scale_color_manual(values = c("With_ANG" = "#E97B5F", "Without_ANG" = "#8B6FCB","With_CRISPR" = "#65B6A0")) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )

```

## predict

### both exponential 
```{r}
# 确保 generation 是 numeric
mean_df$generation <- as.numeric(as.character(mean_df$generation))

#mean_df <- mean_df %>% filter(mean_distance > 0)

# 创建预测范围（包含原始和外推）
predict_gen <- 10^seq(0, 8, by = 0.1)  # from 1 to 1e9

# 遍历每个 model 拟合 log-log 回归
models <- unique(mean_df$model)
# 用于保存 time 到达 0.303 的 generation 和时间

# 准备空的预测结果框
predicted_all <- data.frame()
time_generation <- data.frame()

for (mod in models) {
  sub_df <- mean_df %>%
    filter(model == mod, mean_distance > 0, generation > 0)

  # ✅ 原始坐标拟合：mean_distance ~ generation（不加截距）
  fit <- lm(mean_distance ~ generation + 0, data = sub_df)
  print(mod)
  print(summary(fit))

  # ✅ 预测部分（直接用 generation 拟合）
  pred_df <- data.frame(generation = predict_gen)
  pred_df$predicted <- predict(fit, newdata = pred_df)
  pred_df$mean_distance <- pred_df$predicted
  pred_df$model <- mod
  pred_df$segment <- ifelse(
    pred_df$generation > max(sub_df$generation),
    "extrapolate", "fit"
  )
  predicted_all <- rbind(predicted_all, pred_df)

  # ✅ 求 mean_distance = 0.303 时对应的 generation（线性解方程）
  # 模型形式：mean_distance = b * generation
  b <- coef(fit)[1]  # 因为没有截距，只需提取斜率
  generation_target <- 0.303 / b
  time_hours <- generation_target * 2

  time_generation <- rbind(time_generation, data.frame(
    model = mod,
    generation = generation_target,
    time_hours = time_hours
  ))
}


predicted_all = predicted_all[(predicted_all$segment == "fit" & predicted_all$generation %in% 10^c(1, 2, 3, 4, 5, 6, 7)) | predicted_all$segment == "extrapolate", ]
select_df = mean_df[mean_df$model != "Without_ANG",]
predict_select = predicted_all[predicted_all$model != "Without_ANG",]

time_generation$time_years = time_generation$time_hours/(365*24)
# 替换 model 列中的值
mean_df <- mean_df %>%
  mutate(model = recode(model,
                        "With_ANG" = "MDH+ANG",
                        "Without_ANG" = "MDH",
                        "With_CRISPR" = "MDH+ANG+CRISPR"))
select_df <- select_df %>%
  mutate(model = recode(model,
                        "With_ANG" = "MDH+ANG",
                        "Without_ANG" = "MDH",
                        "With_CRISPR" = "MDH+ANG+CRISPR"))

predicted_all <- predicted_all %>%
  mutate(model = recode(model,
                        "With_ANG" = "MDH+ANG",
                        "Without_ANG" = "MDH",
                        "With_CRISPR" = "MDH+ANG+CRISPR"))

predict_select <- predict_select %>%
  mutate(model = recode(model,
                        "With_ANG" = "MDH+ANG",
                        "Without_ANG" = "MDH",
                        "With_CRISPR" = "MDH+ANG+CRISPR"))

# 绘图
ggplot() +
  geom_point(data = select_df, aes(x = generation, y = mean_distance, color = model), size = 3, alpha = 0.9,position = position_dodge(width = 0)) +
  geom_line(data = predict_select,
            aes(x = generation, y = mean_distance, color = model, linetype = segment),
            size = 0.7, alpha = 0.7) +
  geom_hline(yintercept = 0.3,linetype = "dashed",size = 1,color = "firebrick",alpha = 0.7 )+
  scale_x_log10(
  breaks = 10^c(0, 1, 2, 3, 4, 5, 6, 7, 8),
  labels = scales::trans_format("log10", scales::math_format(10^.x))
  ) +
  scale_y_log10(labels = scales::scientific) +
  scale_linetype_manual(values = c("fit" = "solid", "extrapolate" = "dashed")) +

  scale_color_manual(values = c("MDH+ANG" = "#E97B5F",
                                "MDH" = "#8B6FCB",
                                "MDH+ANG+CRISPR" = "#65B6A0")) +

  labs(
    x = "Generation (log10 scale)",
    y = "Mean Distance (log10 scale)",
    color = "Model",
    linetype = "Segment"
  ) +

  theme_classic(base_size = 18) +
  theme(
    legend.position = "top",
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  guides(linetype = "none",shape = "none")+
  coord_cartesian(xlim = c(1e1, 1e8))  # 设置 x 轴范围：10 ~ 1e8
  

#ggsave(paste("./Figure/both_log_transform.jpg"),width = 7,height = 5)
```
### x exponential
```{r}
# 绘图
select_df = select_df[select_df$model != "MDH",]
predict_select = predict_select[predict_select$model != "MDH",]
ggplot() +
  geom_point(data = select_df, aes(x = generation, y = mean_distance, color = model), size = 3, alpha = 0.9,position = position_dodge(width = 0)) +
  geom_line(data = predict_select,
            aes(x = generation, y = mean_distance, color = model, linetype = segment),
            size = 0.7, alpha = 0.7) +
  geom_hline(yintercept = 0.3,linetype = "dashed",size = 1,color = "firebrick",alpha = 0.7 )+
  scale_x_log10(breaks = 10^c(0, 1, 2, 3, 4, 5, 6, 7, 8),labels = scales::trans_format("log10", scales::math_format(10^.x)) ) +
  #scale_y_log10(labels = scales::scientific) +
  scale_linetype_manual(values = c("fit" = "solid", "extrapolate" = "dashed")) +

  scale_color_manual(values = c("MDH+ANG" = "#E97B5F",
                                "MDH" = "#8B6FCB",
                                "MDH+ANG+CRISPR" = "#65B6A0")) +

  labs(
    x = "Generation (log10 scale)",
    y = "Mean Distance",
    color = "Model",
    linetype = "Segment"
  ) +

  theme_classic(base_size = 18) +
  theme(
    legend.position = "top",
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  guides(linetype = "none",shape = "none")+
  coord_cartesian(xlim = c(1e1, 3e8),ylim = c(0,0.4))  # 设置 x 轴范围：10 ~ 1e8
  

ggsave(paste("./Figure/time_log_transform.pdf"),width = 3.75,height = 5)
```

### no exponential 
```{r}
# 绘图
ggplot() +
  geom_point(data = mean_df[mean_df$model != "MDH",], aes(x = generation, y = mean_distance, color = model), size = 3, alpha = 0.9,position = position_dodge(width = 0)) +
  geom_line(data = predicted_all[predicted_all$model != "MDH",],
            aes(x = generation, y = mean_distance, color = model, linetype = segment),
            size = 0.7, alpha = 0.7) +
  geom_hline(yintercept = 0.3,linetype = "dashed",size = 1,color = "firebrick",alpha = 0.7 )+
  scale_x_continuous(breaks = c(1e7,5.5e7,1e8,1.5e8,2e8,2.5e8))+
  #scale_x_log10(breaks = 10^c(0, 1, 2, 3, 4, 5, 6, 7, 8),labels = scales::trans_format("log10", scales::math_format(10^.x)) ) +
  #scale_y_log10(labels = scales::scientific) +
  scale_linetype_manual(values = c("fit" = "solid", "extrapolate" = "dashed")) +

  scale_color_manual(values = c("MDH+ANG" = "#E97B5F",
                                "MDH" = "#8B6FCB",
                                "MDH+ANG+CRISPR" = "#65B6A0")) +
  labs(
    x = "Generation",
    y = "Mean Distance",
    color = "Model",
    linetype = "Segment"
  ) +

  theme_classic(base_size = 18) +
  theme(
    legend.position = "top",
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  guides(linetype = "none",shape = "none")+
  coord_cartesian(xlim = c(1e7, 2.5e8),ylim = c(0,0.4))  # 设置 x 轴范围：10 ~ 1e8

ggsave("./Figure/no_log_transform.pdf",width = 6,height = 5)
```

## 1-1000000 only
```{r}
ggplot(all_dist_data, aes(x = generation, y = (distance), fill = model)) +
  # violin plot
  #geom_violin(scale = "width", color = "black", alpha = 0.7,adjust = 2) 
  # 连线：用预先计算的平均值数据
  geom_line(data = mean_df,
            aes(x = generation, y = mean_distance, group = model, color = model),
            size = 1.2) +
  
  # 美化主题
  theme_minimal(base_size = 18) +
  labs(
    x = "Generation",
    y = "Distance",
    fill = "Model",
    color = "Model"
  ) +
  
  scale_fill_manual(values = c("MDH+ANG" = "#E97B5F","MDH" = "#8B6FCB","MDH+ANG+CRISPR" = "#65B6A0")) +
  scale_color_manual(values = c("MDH+ANG" = "#E97B5F", "MDH" = "#8B6FCB","MDH+ANG+CRISPR" = "#65B6A0")) +
  scale_x_log10()+
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )
```

# sympatric 2D
## functions for calculating distance
```{r}
# calc_block_distance <- function(block_seq_data ,block_label) {
#   return(as.matrix(dist(block_seq_data[[block_label]],method = "euclidean")))
# }

calc_block_distance <- function(block_seq_data ,block_label) {
  return(as.matrix(dist(block_seq_data[[block_label]],method = "manhattan")))
}
# Example
#block_distance_matrix = calc_block_distance(block_label)


calc_genome_distance <- function(block_seq_data,pop_size) {
  
  pop_genome_dis = matrix(0,nrow = pop_size,ncol = pop_size)
  for (block_label in all_label) {
    if(block_label %in% names(block_seq_data)){
      temp_block_dis = calc_block_distance(block_seq_data,block_label)
      pop_genome_dis = pop_genome_dis + temp_block_dis
    }
    
  }
  
  return(pop_genome_dis)
}

# Example
calc_dis_matrix = function(dist_data,pop_size) {
  temp_pop_block_seq  =   dist_data
  for (blocks in 1:length(dist_data)) {
    temp_pop_block_seq[[blocks]] = dist_data[[blocks]][1:pop_size,]
  }
    
  temp_dist = calc_genome_distance(temp_pop_block_seq,pop_size)/total_length
}

result_3d = function(pop_block_seq=pop_block_seq,sample_size = 1000,pop_size,rds_path = NULL,histo = F){
  #index = 1:pop_size
  index = sample(1:pop_size,sample_size)
  
  temp_pop_block_seq = pop_block_seq
  for (blocks in 1:length(pop_block_seq)) {
    temp_pop_block_seq[[blocks]] = pop_block_seq[[blocks]][index,]
  }
  
  temp_dist = calc_genome_distance(temp_pop_block_seq,sample_size)
  
  temp_dist = temp_dist/total_length
  
  if(histo) {
    # histogram 
    temp_dist_vector = as.vector(temp_dist)
    temp_dist_vector = data.frame(distance = temp_dist_vector[temp_dist_vector!= 0])
    ggplot(temp_dist_vector,aes(x = distance)) + 
      geom_histogram(binwidth = 3e-6) +
      theme_classic(base_size = 20)+
      theme(axis.text.x = element_text(angle = 60,hjust = 1,vjust = 1,size = 13), axis.text = element_text(color = "black"))+
      xlab("Genome Distance")+
      ylab("Count")
    ggsave(rds_path,width = 8,height = 6)
  }
  
  
  # 3d visualize
  cmd_result_3D <- as.data.frame(cmdscale(temp_dist, k = 10))  # k = n 表示提取前n个主成分
  colnames(cmd_result_3D) = paste0("V",1:10)
  return(cmd_result_3D)
}

total_length = 80400
```

## read data
```{r}
remove("sum_plot_data")
for (rep in 1:3) {
  pop_block_seq_temp = readRDS(paste0("./speciation/CRISPR_effect/pop_block_seq_gen_1000000_size_1e+05_rep_",rep,".rds"))
  pop_crispr = readRDS(paste0("./speciation/CRISPR_effect/pop_block_crispr_gen_1000000_size_1e+05_rep_",rep,".rds"))
  
  for(i in 1:10){
    temp_plot_data = result_3d(pop_block_seq = pop_block_seq_temp,pop_size = 10000,sample_size = 1000)
    crispr_index = rownames(temp_plot_data)
    pop_crispr_temp = pop_crispr[as.integer(crispr_index)]
    temp_plot_data = cbind(temp_plot_data,is_crispr = pop_crispr_temp)
    
    if(exists("sum_plot_data")){
      sum_plot_data = rbind(sum_plot_data,temp_plot_data)
    } else {
      sum_plot_data = temp_plot_data
    }
  }
}

library(vegan)
coord_matrix <- sum_plot_data[1:30000, 1:2]
group_info <- factor(sum_plot_data[1:10000, "is_crispr"])

# 执行 adonis2 检验（PERMANOVA）
adonis_result <- adonis2(coord_matrix ~ group_info, method = "euclidean")
```


## density
```{r}
ggplot() +
  # 第一层：CRISPR False（蓝系）
  geom_hex(
    data = sum_plot_data[sum_plot_data$is_crispr == "0",],
    aes(x = V1, y = V2, fill = ..count..),
    alpha = 0.85,
    bins = 40
  ) +
  scale_fill_gradientn(
    colours = c(lighten("#a6cee3",0.2), darken("#1f78b4",0.2), "#08306b"),  # 浅蓝 → 深蓝
    name = "CRISPR False"
  ) +
  new_scale_fill() +

  # 第二层：CRISPR True（红橙系）
  geom_hex(
    data = sum_plot_data[sum_plot_data$is_crispr == "1",],
    aes(x = V1, y = V2, fill = ..count..),
    alpha = 0.65,
    bins = 40
  ) +
  scale_fill_gradientn(
    colours = c("#fdcc8a", "#fc8d59", "#b10026"),  # 浅橙 → 深红
    name = "CRISPR True"
  ) +

  xlab("Coordinate1") +
  ylab("Coordinate2") +
  theme_classic(base_size = 20) +
  theme(legend.position = "right")
  
ggsave(paste0("./Figure/sympatric",".pdf"),width = 8,height = 5,dpi = 300)
```



