---
title: "8.Simulation"
author: "wyj"
date: "`r Sys.Date()`"
link-citations: yes
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---

```{r setup, include = FALSE}
path <- "/Users/wangyujia/Documents/CRISPR:Cas/8.simlation/E.coli_data"
knitr::opts_chunk$set(eval=TRUE, #run code in chunks (default = TRUE)
                       echo = TRUE, #whether to include the source code in the output
                       error = TRUE, #Whether to include error information in the output
                       warning = FALSE, #Whether to include warnings in the output (default = TRUE)
                       message = TRUE, #whether to include reference information in the output
                       cache=TRUE, #whether to cache
                       collapse = FALSE # output in one piece
                       )
knitr::opts_knit$set(root.dir = path)
```

# import packages

```{r}
# load packages
library(dplyr)
library(reshape2)
library(ggplot2)
library(scatterplot3d)
library(dbscan)
library(ggdendro)
library(readr)
library(colorspace)
library(ggnewscale)
library(RColorBrewer)
```

# data preparation

## Whole genome aligment of 50 E.coli genomes
aligned sequence fragments were classified to dispensable, homologous, and unique

```{r}
## WGA result of 50 E.coli genomes using Mugsy
all_aligned_seq = read.table("./all_aligned_seq_50",sep = "\t")
all_aligned_seq$type = rep("dispensable",nrow(all_aligned_seq))
all_aligned_seq$type[all_aligned_seq$mult == 50] = "homologous"
all_aligned_seq$type[all_aligned_seq$mult == 1] = "unique"

all_aligned_seq$mult = as.numeric(all_aligned_seq$mult)

# sequence pool
all_seq_select = all_aligned_seq[all_aligned_seq$length <= 10000,]

## homologous part
### the number of homologous fragments were determined by the reference genome GCF_000005845
homo_seq_select = all_seq_select[(as.numeric(all_seq_select$length) > 1000) &  (all_seq_select$type == "homologous" & all_seq_select$genome == "GCF_000005845"),]
homo_seq_select$trim_seq = (gsub("-", "",homo_seq_select$sequence))
homo_seq_select$trim_length = as.numeric(nchar(homo_seq_select$trim_seq))
homo_seq_select = homo_seq_select[homo_seq_select$trim_length > 1000,]

## uniq insertion part 
uniq_seq_select = all_seq_select[all_seq_select$length >= 1000 & all_seq_select$type == "unique",]
uniq_seq_select = uniq_seq_select[uniq_seq_select$label!="0",]

## generate block labels
uniq_label = unique(uniq_seq_select$label)
homo_label = unique(homo_seq_select$label)
all_label = c(homo_label,uniq_label)

## block_dimensions
homo_block_dimensions = rep(6,length(homo_label))
names(homo_block_dimensions) = homo_label
uniq_block_dimensions = rep(6,length(uniq_label))
names(uniq_block_dimensions) = uniq_label
block_dimensions = c(homo_block_dimensions,uniq_block_dimensions) # block dimensions
names(block_dimensions) = all_label

# total length of simulated genome
total_length = 600*length(homo_label)
# total_length = 80400
```

### parse maf file generated by Mugsy
```{r}
## parse maf file generated by Mugsy
readMAF <- function(maf_file) {
  lines <- readLines(maf_file)
  
  score <- label <- mult <- NA
  maf_df <- data.frame()
  i <- 1
  
  while (i <= length(lines)) {
    line <- trimws(lines[i])
    
    if (startsWith(line, "a")) {
      # 提取 a 行信息
      fields <- strsplit(line, "\\s+")[[1]]
      for (field in fields[-1]) {
        kv <- strsplit(field, "=")[[1]]
        if (length(kv) == 2) {
          if (kv[1] == "score") score <- as.numeric(kv[2])
          if (kv[1] == "label") label <- kv[2]
          if (kv[1] == "mult")  mult  <- as.integer(kv[2])
        }
      }
    }
    
    if (startsWith(line, "s") && i + 1 <= length(lines)) {
      fields <- strsplit(line, "\\s+")[[1]]
     
      new_row <- data.frame(
        score    = score,
        label    = label,
        mult     = mult,
        src      = fields[2],
        start    = as.integer(fields[3]),
        size     = as.integer(fields[4]),
        strand   = fields[5],
        srcSize  = as.integer(fields[6]),
        seq      = fields[7],
        stringsAsFactors = FALSE
      )
      
      maf_df <- rbind(maf_df, new_row)
      i <- i + 1  # skip s and seq line
    } else {
      i <- i + 1  # continue
    }
  }
  
  return(maf_df)
}

```

## 20 strains for NHR
```{r}
## ani matrix of 50 E.coli genomes
ani_matrix = read_delim("./ani_matrix.txt",col_names = F)
ani_matrix=tibble::column_to_rownames(ani_matrix,"X1")
colnames(ani_matrix)=rownames(ani_matrix)

ani_full_matrix = 100 - ani_matrix

colnames(ani_full_matrix) = substr(colnames(ani_full_matrix),1,13)
rownames(ani_full_matrix) = substr(rownames(ani_full_matrix),1,13)

dist_ani = as.dist(ani_full_matrix)
hc = hclust(dist_ani)
groups = cutree(hc, h = 0.3)

dendro_data = dendro_data(hc)
dendro_data$labels$group = as.factor(groups[dendro_data$labels$label])

## define select_strain
select_strain = substr(names(groups[!duplicated(groups)]),1,13)
# remove GCF_003018035 --> 20 genomes with all ANI < 99.8 to each other, (exact number is 99.73%)
select_strain = select_strain[select_strain != "GCF_003018035"]
```

# Simulation functions

## Initiation
```{r}
Init_block_seq <- function(pop_size = 1000) {
  
  pop_block_seq = list()
  
  for (block_label in all_label) {
    ## homologous block
    if (block_label %in% homo_label) {
      pop_block_seq[[block_label]] = matrix(1,nrow = pop_size,ncol = block_dimensions[block_label])
    }
    ## unique_block
    if (block_label %in% uniq_label) {
      pop_block_seq[[block_label]] = matrix(0,nrow = pop_size,ncol = block_dimensions[block_label])
    }
    
    #print(block_label)
  }
  
  return(pop_block_seq)
}

Init_prob_matrix <- function( block_seq_data,decline_index = 18) {
  pop_prob_matrix = list()
  for (block_label in homo_label) {
    pop_prob_matrix[[block_label]] = calc_block_distance(block_seq_data,block_label = block_label)/(block_dimensions[block_label]*100)
    pop_prob_matrix[[block_label]] = 10^(-decline_index*pop_prob_matrix[[block_label]])
    
    #pop_prob_matrix[[block_label]] = apply(pop_prob_matrix[[block_label]],MARGIN = 1, FUN = sum) 
  }
  return(pop_prob_matrix)
} 

#pop_prob_matrix  = Init_prob_matrix(block_seq_data = pop_block_seq)

# Init CRISPR annotation
Init_crispr <- function(pop_size = 1000) {
  pop_crispr = rep(c(1,0),each = pop_size/2)
  return(pop_crispr)
}
```

## Mutation
```{r}
pop_mutation <- function(mutation_per_gen,pop_size ,coeff = drift_prop) {
  count = rpois(1,lambda = mutation_per_gen)
  
  if(count >= 1) {
    select_genome = sample(1:pop_size,count,replace = T)
    select_block = sample(homo_label,count,prob = block_dimensions[homo_label],replace = T)
    
    for (i in 1:count) {
      temp_genome = select_genome[i]
      temp_block = select_block[i]
      
      temp_dim = sample((1:block_dimensions[temp_block]),size = 1)
      pop_block_seq[[temp_block]][temp_genome,temp_dim] <<- pop_block_seq[[temp_block]][temp_genome,temp_dim] + 1
    }
  } 
}

```

## Drift
```{r}
pop_drift <- function(pop_size = 10000, coeff = drift_prop,similarity = T ,length =T) {
  
  if (coeff == 1 ) {
    drift_sample1 = sample(1:pop_size,replace = T)
    for (temp_block in all_label) {
      pop_block_seq[[temp_block]][1:pop_size,] <<-  pop_block_seq[[temp_block]][drift_sample1,]
      rownames(pop_block_seq[[temp_block]]) <<- 1:pop_size
    }
    #pop_crispr <<- pop_crispr[drift_sample1]
    
  } else {
    
    drift_prop = pop_size * coeff
    drift_sample1 = sample(1:pop_size,drift_prop,replace = T)
    drift_sample2 = sample(1:pop_size,drift_prop,replace = T)
    
    for (temp_block in all_label) {
      
      pop_block_seq[[temp_block]][drift_sample1,] <<-  pop_block_seq[[temp_block]][drift_sample2,]
      rownames(pop_block_seq[[temp_block]]) <<- 1:pop_size
      
    }
    #pop_crispr[drift_sample1] <<- pop_crispr[drift_sample2]
    
  }
}


```

## Homologous Recombination

```{r}
pop_recombination <- function(pop_size = 1000, recom_rate) {
  
  recom_count = rpois(1, recom_rate)  # Count of recombination events per generation is sampled from a poisson distribution of parameter 'recom_rate'
  
  if(recom_count >= 1 ){
    temp_block = sample(homo_label,size = recom_count,replace = T)
    select_source = sample(1:pop_size,size = recom_count,replace = T)
    for (i in 1:recom_count) {
      select_target = select_source[i]
      while (select_target == select_source[i]) {
        select_target = sample(1:pop_size,size = 1,replace = T)
      }
      # change target to source
      pop_block_seq[[temp_block[i]]][select_target,] <<-  pop_block_seq[[temp_block[i]]][select_source[i],]
    }
  }
  
}
```

## ANG (sequence insertion)
```{r}
pop_insertion <- function(pop_size = 1000, insert_rate,insert_loss_rate) {
  ## Insertion
  insert_count = rpois(1, insert_rate)  # Count of ANG events per generation is sampled from a poisson distribution of parameter 'recom_rate'
  
  if(insert_count >= 1 ){
    for (i in 1:insert_count) {
      temp_block = uniq_label[(sample(1:length(uniq_label),1))]
      
      insert_target = sample(1:pop_size,size = 1)
      
      # change target to source
      #if(!pop_crispr[insert_target]){
        pop_block_seq[[temp_block]][insert_target,] <<-  rep(1,block_dimensions[temp_block])
      #}
    }
  }
}
```

## Distance calculation
```{r}

calc_block_distance <- function(block_seq_data ,block_label) {
  return(as.matrix(dist(block_seq_data[[block_label]],method = "manhattan")))
}


calc_genome_distance <- function(block_seq_data,pop_size) {
  
  pop_genome_dis = matrix(0,nrow = pop_size,ncol = pop_size)
  for (block_label in all_label) {
    if(block_label %in% names(block_seq_data)){
      temp_block_dis = calc_block_distance(block_seq_data,block_label)
      #temp_block_dis = 
      pop_genome_dis = pop_genome_dis + temp_block_dis
    }
    
  }
  
  return(pop_genome_dis)
}

calc_dis_matrix = function(dist_data,pop_size) {
  temp_pop_block_seq  =   dist_data
  for (blocks in 1:length(dist_data)) {
    temp_pop_block_seq[[blocks]] = dist_data[[blocks]][1:pop_size,]
    temp_dist = calc_genome_distance(temp_pop_block_seq,pop_size)/total_length
  }
}

```

## Record simulation results
```{r}
# plot_function
result_3d = function(sample_size = 1000,pop_size,rds_path = NULL,histo = F){

  index = sample(1:pop_size,sample_size)
  
  temp_pop_block_seq = pop_block_seq
  for (blocks in 1:length(pop_block_seq)) {
    temp_pop_block_seq[[blocks]] = pop_block_seq[[blocks]][index,]
  }
  
  temp_dist = calc_genome_distance(temp_pop_block_seq,sample_size )
  
  temp_dist = temp_dist/total_length
  
  if(histo) {
    # histogram 
    temp_dist_vector = as.vector(temp_dist)
    temp_dist_vector = data.frame(distance = temp_dist_vector[temp_dist_vector!= 0])
    ggplot(temp_dist_vector,aes(x = distance)) + 
      geom_histogram(binwidth = 3e-6) +
      theme_classic(base_size = 20)+
      theme(axis.text.x = element_text(angle = 60,hjust = 1,vjust = 1,size = 13), axis.text = element_text(color = "black"))+
      xlab("Genome Distance")+
      ylab("Count")
    ggsave(rds_path,width = 8,height = 6)
  }
  
  
  # 3d visualize
  cmd_result_3D <- as.data.frame(cmdscale(temp_dist, k = 3))  
  colnames(cmd_result_3D) = c("Coordinate1","Coordinate1","Coordinate1")
  return(cmd_result_3D)
}
```

# Simulation 
## parameters
run_part defines the evolution factors in the simulation
```{r}
args = commandArgs(trailingOnly = TRUE)
population_size = as.numeric(args[1])
rep_num =  as.numeric(args[2])
run_part = as.numeric(args[3])

print(paste0("population size = ",population_size," rep ", rep_num," run part ",run_part))
generation = 1000000
mutation_rate = 1e-9
drift_prop = population_size/100000

mutation_per_gen = (total_length * mutation_rate * population_size)
print(paste("mutation per generation = ",mutation_per_gen,sep	= " "))
```

## Example
```{r}
remove(hist_data)

if(run_part == "MDHAC") {
  ins_rate_to_mut= 0.1 # ins_rate defined as 0.1 times of mutation rate
  recombination_to_mut = 10 # ins_rate defined as 10 times of mutation rate
  
  recom_rate = mutation_per_gen*  recombination_to_mut
  insert_rate = (mutation_per_gen * ins_rate_to_mut)
  
  pop_block_seq = Init_block_seq(pop_size = population_size) # Initiation
  
  for (i in 1:generation) {
    pop_mutation(pop_size = population_size,mutation_per_gen = mutation_per_gen ) # mutation
    pop_recombination(pop_size = population_size,recom_rate = recom_rate) # recombination 
    pop_insertion(pop_size = population_size, insert_rate,insert_loss_rate) # ANG
      
    if(i %% 100 == 0) pop_drift(pop_size = population_size,coeff = drift_prop) # drift
    
    # record 3d plot
    if(i %% 1000000 == 0) {
      for(j in 1:5){
        pdf(paste0("./sim_result_drift/MDHAC_",population_size,"_pop_rep_",rep_num,"_sample_",j,".pdf"), width = 10, height = 10)
        plot_data = result_3d(pop_block_seq,sample_size = 1000,pop_size = population_size)
        write_rds(plot_data,paste0("./sim_result_drift/MDHAC_",population_size,"_pop_rep_",rep_num,"_sample_",j,"_plot_data.rds"))
        scatterplot3d(plot_data, color = "black",
                      pch = 16,          # 点的形状
                      # xlim = c(-0.0005, 0.0005),   # 固定 x 坐标区间
                      # ylim = c(-0.0004, 0.0004),   # 固定 y 坐标区间
                      # zlim = c(-0.0004, 0.0004),   # 固定 z 坐标区间
                      main = paste0("MDH+25%ANG model"," generation: ",i,"\n"),
                      xlab = "Coordinate1", ylab = "Coordinate2", zlab = "Coordinate3")
          
        dev.off()  # 关闭 JPG 设备
      }
    }
      
    ##record dist matrix
    if(i %% 20000 == 0){
      index = sample(1:population_size,1000)
      temp_pop_block_seq = pop_block_seq
      for (blocks in 1:length(pop_block_seq)) {
        temp_pop_block_seq[[blocks]] = pop_block_seq[[blocks]][index,]
      }
        
      temp_dist = calc_genome_distance(temp_pop_block_seq,1000 )
      temp_dist = temp_dist/total_length
      #write_rds(temp_dist,paste0("./sim_result_drift/Sim5/Insertion_rates_",i,"_",ins_rate_to_mut,"_dist.rds"))
      hist_dist = (hist(x = as.vector(temp_dist),plot = F,breaks = seq(0,max(as.vector(temp_dist))+0.00005,0.00005)))
        
      temp_hist_data = data.frame(counts = hist_dist$counts/2,density = hist_dist$density,mids = hist_dist$mids,generation = rep(i,length(hist_dist$counts)))
        
      if(exists("hist_data")) {
        hist_data = rbind(hist_data,temp_hist_data)
      } else {
        hist_data = temp_hist_data
      }
      print(i)
    }
  }
  write_rds(hist_data,paste0("./sim_result_drift/hist_time_crispr_",population_size,"_pop_rep_",rep_num,".rds"))
}

```

